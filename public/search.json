[{"categories":["技术博客"],"content":"Floyd 判圈算法（Floyd’s Cycle Detection Algorithm） 什么是 Floyd 判圈算法？ Floyd 判圈算法，也叫 龟兔赛跑算法（Tortoise and Hare Algorithm），是一种用于检测链表中是否存在环的算法。该算法由 Robert W. Floyd 提出，旨在通过两个不同速度的指针遍历链表来判断链表是否存在循环。其时间复杂度为 O(n)，空间复杂度为 O(1)，因此在效率和资源占用方面非常优越。\n算法原理 Floyd 判圈算法使用两个指针：\n慢指针（Tortoise）：每次移动一步。 快指针（Hare）：每次移动两步。 如果链表中存在环，那么快指针和慢指针最终会在环中相遇。如果链表中不存在环，快指针会先到达链表的末端。\n主要步骤如下： 初始化两个指针：慢指针 slow 和快指针 fast 都指向链表的头部。 快指针每次移动两步，慢指针每次移动一步。 如果快指针和慢指针在某个时刻相遇，则说明链表中存在环。 如果快指针到达 null（链表的末尾），则说明链表中没有环。 代码实现 下面是使用 Python 实现的 Floyd 判圈算法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def has_cycle(head): slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next # 慢指针每次移动一步 fast = fast.next.next # 快指针每次移动两步 if slow == fast: # 如果相遇，则存在环 return True return False # 如果遍历结束没有相遇，则不存在环 示例解释 假设我们有一个链表，如下所示：\n1 1 -\u003e 2 -\u003e 3 -\u003e 4 -\u003e 5 -\u003e 2 (环) 在此例中，节点 5 指向节点 2，形成了一个环。使用上述代码，快慢指针最终会在环中相遇，从而检测出链表中存在环。\n算法复杂度分析 时间复杂度：O(n)，其中 n 是链表的节点数量。虽然快指针每次走两步，但整体仍然是线性时间复杂度，因为每个节点最多会被访问两次。 空间复杂度：O(1)，因为该算法只使用了两个额外的指针，不需要额外的空间存储其他数据。 应用场景 Floyd 判圈算法主要用于检测链表中的环，但它在其他问题中也能发挥作用，例如：\n图的遍历中用于检测循环路径。 编译器中检测循环依赖。 动态数据结构中检测重复模式或回路。 总结 Floyd 判圈算法是一种高效且简单的算法，适用于检测链表中的环。相比于其他算法，它的优势在于时间复杂度和空间复杂度的平衡。在解决链表环问题时，这个算法是首选之一。如果你正在处理链表结构或者需要在图结构中寻找循环，Floyd 算法将是一个强大的工具。\n","description":"本文介绍了 Floyd 判圈算法的原理和应用，并结合代码示例讲解了如何通过该算法检测链表中的环。","tags":["算法","Floyd 判圈算法","数据结构"],"title":"Floyd 判圈算法","uri":"/posts/floyd-algorithm/"},{"categories":["技术博客"],"content":"Optional\u003cT\u003e 是 Java 8 引入的一个容器类，用来解决 null 引用的问题。它可以包含或不包含一个非空值。Optional 主要用于避免 NullPointerException，使代码更加安全和可读。\n创建 Optional 对象 有几种方式可以创建一个 Optional 对象：\n1. Optional.of(T value) 这个方法用于创建包含非空值的 Optional 对象。如果传入的值为 null，它会抛出 NullPointerException。\n1 Optional\u003cString\u003e optional = Optional.of(\"Hello\"); 2. Optional.ofNullable(T value) 这个方法允许传入一个可能为 null 的值。如果值为 null，它会返回一个空的 Optional 对象；否则返回一个包含该值的 Optional。\n1 Optional\u003cString\u003e optional = Optional.ofNullable(null); // 空的 Optional Optional\u003cString\u003e optional2 = Optional.ofNullable(\"Hello\"); // 包含 \"Hello\" 的 Optional 3. Optional.empty() 创建一个空的 Optional 对象，不包含任何值。\n1 Optional\u003cString\u003e optional = Optional.empty(); 使用 Optional 的常用方法 1. isPresent() 检查 Optional 是否包含值。如果值存在，返回 true，否则返回 false。\n1 2 3 4 Optional\u003cString\u003e optional = Optional.of(\"Hello\"); if (optional.isPresent()) { System.out.println(optional.get()); // 输出 \"Hello\" } 2. ifPresent(Consumer\u003c? super T\u003e action) 如果 Optional 中包含值，就执行给定的 Consumer 操作，否则不执行。\n1 optional.ifPresent(value -\u003e System.out.println(value)); // 输出 \"Hello\" 3. orElse(T other) 如果 Optional 中包含值，返回该值；如果为空，则返回一个默认值。\n1 2 String value = optional.orElse(\"Default Value\"); System.out.println(value); // 输出 \"Hello\" 或 \"Default Value\" 4. orElseGet(Supplier\u003c? extends T\u003e other) 类似于 orElse()，但可以通过传递 Supplier 来动态生成默认值。\n1 2 String value = optional.orElseGet(() -\u003e \"Generated Value\"); System.out.println(value); // 输出 \"Hello\" 或 \"Generated Value\" 5. orElseThrow(Supplier\u003c? extends X\u003e exceptionSupplier) 如果 Optional 中包含值，返回该值；如果为空，抛出自定义的异常。\n1 String value = optional.orElseThrow(() -\u003e new IllegalArgumentException(\"No value present\")); 6. get() 返回 Optional 中包含的值。如果为空，则抛出 NoSuchElementException。\n1 2 Optional\u003cString\u003e optional = Optional.of(\"Hello\"); System.out.println(optional.get()); // 输出 \"Hello\" 注意：使用 get() 之前应当确保 Optional 中有值，可以配合 isPresent() 或者 ifPresent() 来避免异常。\n7. map(Function\u003c? super T,? extends U\u003e mapper) 如果 Optional 中存在值，则对其应用 Function 并返回新的 Optional，否则返回空的 Optional。\n1 2 3 Optional\u003cString\u003e optional = Optional.of(\"Hello\"); Optional\u003cInteger\u003e length = optional.map(String::length); System.out.println(length.get()); // 输出 5 8. flatMap(Function\u003c? super T, Optional\u003cU\u003e\u003e mapper) 与 map() 类似，但 mapper 返回的是一个 Optional，而不是直接返回值，用于嵌套的 Optional 解包。\n1 2 3 Optional\u003cString\u003e optional = Optional.of(\"Hello\"); Optional\u003cString\u003e result = optional.flatMap(value -\u003e Optional.of(value.toUpperCase())); System.out.println(result.get()); // 输出 \"HELLO\" 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import java.util.Optional; public class Main { public static void main(String[] args) { // 创建一个 Optional 包含 \"Hello\" Optional\u003cString\u003e optional = Optional.of(\"Hello\"); // 检查值是否存在 if (optional.isPresent()) { System.out.println(\"Value is present: \" + optional.get()); } // 使用 orElse 方法获取值或默认值 String value = optional.orElse(\"Default Value\"); System.out.println(\"The value is: \" + value); // 使用 map 转换值 Optional\u003cInteger\u003e length = optional.map(String::length); System.out.println(\"Length of the string is: \" + length.get()); // 使用 flatMap 链式操作 Optional\u003cString\u003e result = optional.flatMap(val -\u003e Optional.of(val.toUpperCase())); System.out.println(\"Uppercased value: \" + result.get()); } } 总结 Optional 是一个非常有用的工具，可以有效避免 null 引用问题，增强代码的可读性和健壮性。通过合理使用 Optional 的各种方法，你可以更好地管理代码中的空值处理逻辑。\n","description":"Optional 是 Java 8 引入的一个容器类，用来解决 null 引用的问题。它可以包含或不包含一个非空值。","tags":["容器类","Java"],"title":"Java中的Optional类","uri":"/posts/java%E4%B8%AD%E7%9A%84optional%E7%B1%BB/"},{"categories":["技术博客"],"content":"JpaRepository 是 Spring Data JPA 中的一个接口，提供了对数据库实体进行CRUD（Create, Read, Update, Delete）操作的常用方法。它继承自 PagingAndSortingRepository 和 CrudRepository，并且提供了一些额外的 JPA 相关的功能。\n使用 JpaRepository 的基本步骤 1. 创建实体类 首先，你需要定义一个实体类并使用 @Entity 注解来标记它。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import javax.persistence.Entity; import javax.persistence.Id; @Entity public class User { @Id private Long id; private String name; private String email; // getters and setters } 2. 创建 JpaRepository 接口 你需要创建一个接口，并让它继承 JpaRepository，其中泛型参数为 \u003cEntityClass, IDType\u003e，即实体类的类型和其主键类型。\n1 2 3 4 5 import org.springframework.data.jpa.repository.JpaRepository; public interface UserRepository extends JpaRepository\u003cUser, Long\u003e { // 你可以在这里添加自定义查询方法 } UserRepository 接口继承了 JpaRepository，这样你就可以直接使用很多内置的方法。\n3. 使用 JpaRepository 提供的内置方法 JpaRepository 为我们提供了很多内置的操作方法，比如：\nsave(S entity)：保存实体对象。 findById(ID id)：通过主键查找实体。 findAll()：获取所有实体。 deleteById(ID id)：通过主键删除实体。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.List; import java.util.Optional; @Service public class UserService { @Autowired private UserRepository userRepository; public List\u003cUser\u003e getAllUsers() { return userRepository.findAll(); } public Optional\u003cUser\u003e getUserById(Long id) { return userRepository.findById(id); } public User saveUser(User user) { return userRepository.save(user); } public void deleteUser(Long id) { userRepository.deleteById(id); } } 自定义查询方法 除了 JpaRepository 提供的内置方法，你还可以在接口中定义自定义查询方法，Spring Data JPA 会根据方法名称自动生成查询。\n例如：\n1 2 3 4 5 6 7 8 9 10 import java.util.List; public interface UserRepository extends JpaRepository\u003cUser, Long\u003e { // 自定义方法：通过用户名查找用户 List\u003cUser\u003e findByName(String name); // 自定义方法：通过邮箱查找用户 User findByEmail(String email); } JpaRepository 常见内置方法 save(S entity)：保存或更新实体。 delete(T entity)：删除实体。 findAll()：查询所有实体。 findById(ID id)：根据ID查找实体。 count()：返回实体总数。 existsById(ID id)：检查某个实体是否存在。 总结 JpaRepository 是一个非常强大的接口，能够简化很多数据库操作。通过它，你可以轻松地完成对数据库的增删改查，并且可以自定义查询方法，极大地提升了开发效率。\n","description":"JpaRepository 是 Spring Data JPA 中的一个接口，提供了对数据库实体进行CRUD（Create, Read, Update, Delete）操作的常用方法。","tags":["SpringBoot","Spring Data JPA","Java"],"title":"Spring Data JPA 的JpaRepository","uri":"/posts/spring-data-jpa-%E7%9A%84jparepository/"},{"categories":["技术博客"],"content":"在 Spring MVC 中，Model 用于在控制器和视图之间传递数据。当你在控制器方法中使用 model.addAttribute() 添加数据时，这些数据会自动被传递到视图（如 Thymeleaf、JSP 等），并在视图中通过模型属性的名字进行访问。\nModel 传参的具体流程 1.控制器方法传递数据到视图：\n在控制器中，使用 model.addAttribute() 方法将一个对象添加到 Model。 Spring MVC 会将这个对象作为请求属性传递给视图（比如 Thymeleaf 模板）。 视图渲染时，可以通过模型中提供的属性来访问并显示数据。 示例代码： 1 2 3 4 5 6 @GetMapping(\"/types/input\") public String input(Model model) { // 创建一个新的 Type 对象，并通过 addAttribute 将其放入 Model 中 model.addAttribute(\"type\", new Type()); return \"admin/types-input\"; // 返回视图名 } ​ 在上面的代码中，model.addAttribute(\"type\", new Type()) 将一个 Type 对象存储在模型中，键名为 \"type\"。\n2.视图中获取和使用模型数据：\n在视图模板中（例如 Thymeleaf），你可以通过指定的键名来访问 Model 中的数据。键名是 addAttribute 中的第一个参数（如 \"type\"），通过这个键名，视图可以使用绑定的对象进行显示或表单字段的初始化。 示例 Thymeleaf 视图（admin/types-input.html）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003c!DOCTYPE html\u003e \u003chtml xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003ctitle\u003eType Input\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eInput Type\u003c/h1\u003e \u003c!-- 表单绑定到 type 对象的 name 属性 --\u003e \u003cform th:action=\"@{/types/save}\" method=\"post\"\u003e \u003clabel for=\"name\"\u003eType Name:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" th:field=\"*{name}\" placeholder=\"Enter type name\"\u003e \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e th:field=\"*{name}\" 这里的 *{name} 表示从 Model 中绑定的 type 对象的 name 属性。 Spring MVC 自动将 Type 对象放入 Model 中，所以 Thymeleaf 模板能够直接访问 Type 对象的属性。 当页面加载时，th:field 会预先将 type.name 的值显示在表单中（如果有值）。在提交表单时，输入的数据会绑定到 Type 对象的 name 属性。 Model 的传递过程 1. 数据存入 Model： 在控制器方法中调用 model.addAttribute(\"type\", new Type())，将键值对存入 Model。 这里 \"type\" 是键，new Type() 是对应的值（对象）。 2. 传递到视图： Spring MVC 将模型中的所有键值对放入 HTTP 请求的属性中，传递到视图层。 模型中的数据自动与视图解析器（如 Thymeleaf、JSP）关联，视图模板可以通过模型中的键名来访问对象。 3. 视图访问模型数据： 在视图模板中，可以通过 type 键名直接访问绑定的 Type 对象，并且可以使用这个对象来填充表单字段、显示数据，或进行其他操作。 具体示例：完整的控制器与视图交互 1. 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Controller public class TypeController { @GetMapping(\"/types/input\") public String input(Model model) { // 创建一个新的 Type 对象，传递给视图 model.addAttribute(\"type\", new Type()); return \"admin/types-input\"; // 返回视图名称 } @PostMapping(\"/types/save\") public String save(@ModelAttribute Type type) { // 在这里处理保存操作，Type 对象会自动绑定表单提交的数据 System.out.println(\"Saved Type: \" + type.getName()); return \"redirect:/types/list\"; // 重定向到类型列表页面 } } 2. 视图模板（admin/types-input.html） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003c!DOCTYPE html\u003e \u003chtml xmlns:th=\"http://www.thymeleaf.org\"\u003e \u003chead\u003e \u003ctitle\u003eType Input\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eInput Type\u003c/h1\u003e \u003c!-- 使用 th:field 来绑定 type 对象的 name 属性 --\u003e \u003cform th:action=\"@{/types/save}\" method=\"post\"\u003e \u003clabel for=\"name\"\u003eType Name:\u003c/label\u003e \u003cinput type=\"text\" id=\"name\" th:field=\"*{name}\" placeholder=\"Enter type name\"\u003e \u003cbutton type=\"submit\"\u003eSubmit\u003c/button\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 总结 Model 在控制器和视图之间扮演了数据传递的桥梁。 在控制器中，你可以通过 model.addAttribute() 将数据传递给视图，视图模板可以通过指定的键名访问这些数据。 这种方式通常用于表单提交的场景，视图层会根据控制器传递的对象进行表单数据的绑定和显示。 ","description":"Spring MVC中，Model实现控制器与视图的数据传递与绑定。","tags":["SpringBoot","Spring MVC","Java"],"title":"Spring MVC 中的Model","uri":"/posts/spring-mvc-%E4%B8%AD%E7%9A%84model/"}]
